const { Router } = require('express');
const pdfParse = require('pdf-parse');
const llenarYMarcarPDF = require('../../utils/pdf_generator');
const path = require('path');
const fs = require('fs');
const os = require('os');
const router = Router()
const ReportDAO = require('../../dao/class/dao.report');
const Report = new ReportDAO;

router.post('/llenar-pdf', async (req, res) => {
    const reportData = req.body;
    const {incidentId} = req.body;
    //comentario
    try {
        // Llama a la función para llenar y marcar el PDFs
        const pdfBytes = await llenarYMarcarPDF(reportData);
        // Guarda el PDF generado como reporte
        await Report.subirReporte(incidentId, reportData);
        // Envía el PDF generado como respuesta

        // const pdfPath = path.join(__dirname, '../../utils/formulario_lleno.pdf');
        // res.setHeader('Content-Type', 'application/pdf');
        // res.setHeader('Content-Disposition', 'attachment; filename=formulario_lleno.pdf');
        // Envía el PDF generado como respuesta
        const tempFilePath = path.join(os.tmpdir(), `formulario_${incidentId}.pdf`);
        fs.writeFileSync(tempFilePath, pdfBytes);
        res.setHeader('Content-Type', 'application/pdf');
        res.sendFile(tempFilePath, () => {
            // Después de enviar el archivo, elimina el archivo temporal
            fs.unlink(tempFilePath, (err) => {
                if (err) {
                    console.error('Error al eliminar el archivo temporal:', err);
                }
            });
        });

    } catch (error) {
        console.error(error);
        res.status(500).send('Error al generar el PDF');
    }
});


//Get report by ID, create a PDF and send it to the user
router.get('/report/:incidentId', async (req, res) => {
    const incidentId = req.params.incidentId;
    try {
        const report = await Report.getReportByIncidentId(incidentId);
        if (!report) {
            res.status(404).json({ message: 'Reporte no encontrado' }); 
        }
        // Llama a la función para llenar y marcar el PDF
        const pdfBytes = await llenarYMarcarPDF(report);

        const pdfData = await pdfParse(pdfBytes);
        if (!pdfData.text) {
            throw new Error('Los datos generados no son un PDF válido');
        }
        // Envía el PDF generado como respuesta
        // const pdfPath = path.join(__dirname, '../../utils/formulario_lleno.pdf');
        // res.setHeader('Content-Type', 'application/pdf');
        // res.setHeader('Content-Disposition', 'attachment; filename=formulario_lleno.pdf');
        const tempFilePath = path.join(os.tmpdir(), `formulario_${incidentId}.pdf`);
        fs.writeFileSync(tempFilePath, pdfBytes);
        res.setHeader('Content-Type', 'application/pdf');
        res.sendFile(tempFilePath, () => {
            // Después de enviar el archivo, elimina el archivo temporal
            fs.unlink(tempFilePath, (err) => {
                if (err) {
                    console.error('Error al eliminar el archivo temporal:', err);
                }
            });
        });

        //res.download(pdfBytes);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
});

//get the report generated by the user in llenar-pdf
router.get('/reporte-generado/last', async (req, res) => {
    const pdfPath = path.join(__dirname, '../../utils/formulario_lleno.pdf');
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename=formulario_lleno.pdf');
    res.download(pdfPath);
});

// Define el endpoint para obtener los valores del reporte por incidentId
router.get('/reporte/:incidentId', async (req, res) => {
  try {
    const incidentId = req.params.incidentId;
    // Busca el reporte por incidentId en la base de datos
    const report = await Report.getReportByIncidentId(incidentId);
    // Si el reporte no se encuentra, devuelve un error 404
    if (!report) {
      return res.status(404).json({ message: 'Reporte no encontrado' });
    }

    // Si el reporte se encuentra, devuelve los valores del reporte
    res.json(report);

  } catch (error) {
    // Si ocurre algún error, devuelve un error 500
    console.error(error);
    res.status(500).json({ message: 'Error al obtener los valores del reporte' });
  }
});

module.exports = router