const { Router } = require('express');
const pdfParse = require('pdf-parse');
const llenarYMarcarPDF = require('../../utils/pdf_generator');
const path = require('path');
const fs = require('fs');
const os = require('os');
const router = Router()
const ReportDAO = require('../../dao/class/dao.report');
const IncidentDAO = require('../../dao/class/dao.incident');
const Incident = new IncidentDAO;
const Report = new ReportDAO;
const zip = require('express-zip');

// Fill and mark a PDF with the data from the request body
router.post('/llenar-pdf', async (req, res) => {
    const reportData = req.body;
    const incidentId = reportData.incidentId;
    if (!reportData) {
        return res.status(500).json({ message: 'Datos del reporte no encontrados' });
    }
    try {
        const incident = await Incident.getIncidentByIdAndCompanyId(incidentId);
        if (!incident) {
            return res.status(404).json({ message: 'Incidente no encontrado' });
        }
        // Llama a la función para llenar y marcar el PDFs
        const pdfBytes = await llenarYMarcarPDF(reportData);
        // Guarda el PDF generado como reporte
        const newReport = await Report.subirReporte(reportData);
        if (!newReport) {
            return res.status(500).json({ message: 'Error al guardar el reporte' });
        }
        // Envía el PDF generado como respuesta
        const tempFilePath = path.join(os.tmpdir(), `formulario_${incident.numberId}.pdf`);
        fs.writeFileSync(tempFilePath, pdfBytes);
        res.setHeader('Content-Type', 'application/pdf');
        res.sendFile(tempFilePath, () => {
            // Después de enviar el archivo, elimina el archivo temporal
            fs.unlink(tempFilePath, (err) => {
                if (err) {
                    console.error('Error al eliminar el archivo temporal:', err);
                }
            });
        });
        res.status(201).json({ message: 'Reporte guardado' });
    } catch (error) {
        console.error(error);
        res.status(500).send({message:'Error al generar reporte'});
    }
});

// Get report by ID, create a PDF and send it to the user
router.get('/report/:incidentId', async (req, res) => {
    const incidentId = req.params.incidentId;
    try {
        const report = await Report.getReportByIncidentId(incidentId);
        if (!report) {
            res.status(404).json({ message: 'Reporte no encontrado' }); 
        }
        // Llama a la función para llenar y marcar el PDF
        const pdfBytes = await llenarYMarcarPDF(report);

        const pdfData = await pdfParse(pdfBytes);
        if (!pdfData.text) {
            throw new Error('Los datos generados no son un PDF válido');
        }
        // Envía el PDF generado como respuesta
        const tempFilePath = path.join(os.tmpdir(), `formulario_${incidentId}.pdf`);
        fs.writeFileSync(tempFilePath, pdfBytes);
        res.setHeader('Content-Type', 'application/pdf');
        res.sendFile(tempFilePath, () => {
            // Después de enviar el archivo, elimina el archivo temporal
            fs.unlink(tempFilePath, (err) => {
                if (err) {
                    console.error('Error al eliminar el archivo temporal:', err);
                }
            });
        });
        //res.download(pdfBytes);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
});

//get the report generated by the user in llenar-pdf
router.get('/reporte-generado/last', async (req, res) => {
    const pdfPath = path.join(__dirname, '../../utils/formulario_lleno.pdf');
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename=formulario_lleno.pdf');
    res.download(pdfPath);
});

// Get report by incidentId (values only)
router.get('/reporte/:incidentId', async (req, res) => {
  try {
    const incidentId = req.params.incidentId;
    // Busca el reporte por incidentId en la base de datos
    const report = await Report.getReportByIncidentId(incidentId);
    // Si el reporte no se encuentra, devuelve un error 404
    if (!report) {
      return res.status(404).json({ message: 'Reporte no encontrado' });
    }

    // Si el reporte se encuentra, devuelve los valores del reporte
    res.json(report);

  } catch (error) {
    // Si ocurre algún error, devuelve un error 500
    console.error(error);
    res.status(500).json({ message: 'Error al obtener los valores del reporte' });
  }
});

// Download multiple reports as a ZIP file
router.post('/reportes', async (req, res) => {
    const pdfFiles = [];
    const { incidentIds } = req.body;
    try {
        for (const incidentId of incidentIds) {
            const report = await Report.getReportByIncidentId(incidentId);
            const incident = await Incident.getIncidentByIdAndCompanyId(incidentId);
            if (report) {
                const pdfBytes = await llenarYMarcarPDF(report);
                const tempFilePath = path.join(os.tmpdir(), `formulario_${incident.numberId}.pdf`);
                fs.writeFileSync(tempFilePath, pdfBytes);
                pdfFiles.push({ path: tempFilePath, name: `formulario_${incident.numberId}.pdf` });
            }
        }
        if (pdfFiles.length === 0) {
            return res.status(404).json({ message: 'No se encontraron reportes' });
        }
        res.zip(pdfFiles, 'reportes.zip');
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Error al obtener los reportes' + error.message });
    }
});

module.exports = router